// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.200703.9

#ifndef WINRT_SimpleMathComponent_H
#define WINRT_SimpleMathComponent_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.200703.9"), "Mismatched C++/WinRT headers.");
#include "winrt/impl/SimpleMathComponent.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(double) consume_SimpleMathComponent_ISimpleMath<D>::add(double firstNumber, double secondNumber) const
    {
        double result{};
        check_hresult(WINRT_IMPL_SHIM(SimpleMathComponent::ISimpleMath)->add(firstNumber, secondNumber, &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_SimpleMathComponent_ISimpleMath<D>::subtract(double firstNumber, double secondNumber) const
    {
        double result{};
        check_hresult(WINRT_IMPL_SHIM(SimpleMathComponent::ISimpleMath)->subtract(firstNumber, secondNumber, &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_SimpleMathComponent_ISimpleMath<D>::multiply(double firstNumber, double secondNumber) const
    {
        double result{};
        check_hresult(WINRT_IMPL_SHIM(SimpleMathComponent::ISimpleMath)->multiply(firstNumber, secondNumber, &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_SimpleMathComponent_ISimpleMath<D>::divide(double firstNumber, double secondNumber) const
    {
        double result{};
        check_hresult(WINRT_IMPL_SHIM(SimpleMathComponent::ISimpleMath)->divide(firstNumber, secondNumber, &result));
        return result;
    }
    template <typename D>
    struct produce<D, SimpleMathComponent::ISimpleMath> : produce_base<D, SimpleMathComponent::ISimpleMath>
    {
        int32_t __stdcall add(double firstNumber, double secondNumber, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().add(firstNumber, secondNumber));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall subtract(double firstNumber, double secondNumber, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().subtract(firstNumber, secondNumber));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall multiply(double firstNumber, double secondNumber, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().multiply(firstNumber, secondNumber));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall divide(double firstNumber, double secondNumber, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().divide(firstNumber, secondNumber));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::SimpleMathComponent
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::SimpleMathComponent::ISimpleMath> : winrt::impl::hash_base {};
    template<> struct hash<winrt::SimpleMathComponent::SimpleMath> : winrt::impl::hash_base {};
#endif
}
#endif
